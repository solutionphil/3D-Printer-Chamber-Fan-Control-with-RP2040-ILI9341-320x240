void loop(void) {
  // Main loop to handle touch input and update screens
  uint16_t t_x = 0, t_y = 0;  // Variables to store touch coordinates
  bool pressed = tft.getTouch(&t_x, &t_y);  // Boolean indicating if the screen is being touched

  // Update sensors in a non-blocking way
  updateSensors();

  // Check if fan changes need to be saved
  if (fanChangesPending && (millis() - lastFanChange >= FAN_SAVE_DELAY)) {
    saveFanSpeeds(currentFanSpeeds);
    fanChangesPending = false;
    Serial.println("Saved fan settings after delay");
  }

  // Handle temperature and air quality screen updates
  if (currentScreen == 3) {
    unsigned long currentMillis = millis();
    if (currentMillis - lastSensorUpdate >= SENSOR_UPDATE_INTERVAL)
      updateTempAndAirQualityDisplay();
  }
    // Handle temperature and air quality screen updates
  if (currentScreen == 1) {
    unsigned long currentMillis = millis();
    if (currentMillis - lastSensorUpdate >= SENSOR_UPDATE_INTERVAL)
      updatePIDDisplay();
      
    // Handle PID control button presses
    if (pressed) {
      // Check PID toggle button
      if (t_x >= 20 && t_x <= 70 && t_y >= 200 && t_y <= 250) {
        if (millis() - lastButtonPress >= DEBOUNCE_DELAY) {
          lastButtonPress = millis();
         if (PIDactive = !PIDactive)
         {
             myPID.SetMode(myPID.Control::automatic);
          }
          else
          {
            myPID.SetMode(myPID.Control::manual);
          }
          savePIDSettings();
          updatePIDDisplay();
        }
      }
      // Check Up button
      else if (t_x >= 170 && t_x <= 230 && t_y >= 150 && t_y <= 190) {
        if (millis() - lastButtonPress >= DEBOUNCE_DELAY) {
          lastButtonPress = millis();
          Setpoint += 0.5;
          savePIDSettings();
          updatePIDDisplay();
        }
      }
      // Check Down button
      else if (t_x >= 170 && t_x <= 230 && t_y >= 220 && t_y <= 260) {
        if (millis() - lastButtonPress >= DEBOUNCE_DELAY) {
          lastButtonPress = millis();
          Setpoint -= 0.5;
          savePIDSettings();
          updatePIDDisplay();
        }
      }
    }
  }

  if (currentScreen == 0) {  // Main menu screen (System Info removed)
    for (uint8_t b = 0; b < 4; b++) {  // Adjusted loop to 4 buttons
      mainMenuButtons[b].press(pressed && mainMenuButtons[b].contains(t_x, t_y));  // Update button state
    }

    for (uint8_t b = 0; b < 4; b++) {  // Adjusted loop to 4 buttons
      if (mainMenuButtons[b].justReleased()) mainMenuButtons[b].drawButton();  // Draw normal state
      if (mainMenuButtons[b].justPressed()) {
        unsigned long currentTime = millis();
        if (currentTime - lastButtonPress >= DEBOUNCE_DELAY) {
          lastButtonPress = currentTime + 50; // Add extra delay for button presses
          switch(b) {
            case 0: currentScreen = 7; break;  // Fans (moved from Settings)
            case 1: currentScreen = 3; break;  // Temperature and Air Quality
            case 2: currentScreen = 1; break;  // PID
            case 3: currentScreen = 5; break;  // Settings
          }
          displayScreen(currentScreen);  // Display the selected screen
        }
      }
    }
  } else if (currentScreen == 5) {  // Settings menu
    for (uint8_t b = 0; b < 4; b++) {  // Adjusted to 4 buttons for Settings
      mainMenuButtons[b].press(pressed && mainMenuButtons[b].contains(t_x, t_y));
      if (mainMenuButtons[b].justPressed()) {
        unsigned long currentTime = millis();
        if (currentTime - lastButtonPress >= DEBOUNCE_DELAY) {
          lastButtonPress = currentTime;
          if (b == 0) currentScreen = 2;      // Brightness
          else if (b == 1) {  // File Explorer
            displayLoadingScreen();
            currentScreen = 4;
          }
          else if (b == 2) currentScreen = 6;  // LED Control
          else if (b == 3) currentScreen = 8;  // System Info
          displayScreen(currentScreen);
        }
      }
    }
  } else if (currentScreen == 6) {
    mainMenuButtons[0].press(pressed && mainMenuButtons[0].contains(t_x, t_y));
    if (mainMenuButtons[0].justPressed()) {
      neopixelState = !neopixelState;
      if (!neopixelState) {
        pixels.setPixelColor(0, 0);
      } else {
        pixels.setPixelColor(0, pixels.Color(255, 255, 255));
        setNeoPixelColor(currentScreen);
      }
      pixels.show();
      saveLEDState(neopixelState);
      displayLEDControl();
      delay(500);
    }
  } else if (currentScreen == 7) {
    for (uint8_t b = 0; b < 3; b++) {
      mainMenuButtons[b].press(pressed && mainMenuButtons[b].contains(t_x, t_y));
      if (mainMenuButtons[b].justPressed()) {
        unsigned long currentTime = millis();
        if (currentTime - lastButtonPress >= DEBOUNCE_DELAY) {
          lastButtonPress = currentTime;
          displayFanControl(b);
        }
      }
    }
  } else if (currentScreen == 2) {
    if (pressed) {
      if (slider1.checkTouch(t_x, t_y)) {
        // Handle slider touch logic
        dutyCycle = round(slider1.getSliderPosition() / 10.0) * 10.0; // Snap to nearest 10% increment
        slider1.setSliderPosition(dutyCycle); // Update slider position to snapped value
        PWM_Instance->setPWM(pinToUse, frequency, dutyCycle);
        saveBrightness(dutyCycle);  // Save the new brightness value
        // Update percentage display
        tft.fillRect(90, 110, 80, 30, TFT_BLACK);
        tft.setTextColor(TFT_GREEN);
        tft.drawString(String(int(dutyCycle)) + "%", 100, 120);
      }
    }
  }

  // Check for touch on the screen switch button
  if(currentScreen!=0){
    screenButton.press(pressed && screenButton.contains(t_x, t_y));
    if (screenButton.justReleased()) screenButton.drawButton();

    // Switch to the next screen when the button is pressed
      if (screenButton.justPressed()) {
        unsigned long currentTime = millis();
        if (currentTime - lastButtonPress >= DEBOUNCE_DELAY) {
          lastButtonPress = currentTime;
          // Return to settings menu for specific screens
          if (currentScreen == 2 || currentScreen == 4 || currentScreen == 6 || currentScreen == 8) {
            currentScreen = 5;  // Return to Settings
          } else {
            currentScreen = 0;  // Return to Main Menu for other screens
          }
          displayScreen(currentScreen);
      }
    }
  }

  // Check for touch on file explorer buttons only on screen 4
  if (currentScreen == 4) {
    // Clear any residual touch data to prevent accidental button presses
    t_x=0;
    t_y=0;
    while (tft.getTouch(&t_x, &t_y)) {}

    // Additional delay specifically for file explorer to prevent immediate touch processing
    delay(100);

    for (uint8_t i = 0; i < 10; i++) {
      fileButtons[i].press(pressed && fileButtons[i].contains(t_x, t_y));

      // Handle file button interactions
      if (fileButtons[i].justReleased()) fileButtons[i].drawButton();
      if (fileButtons[i].justPressed()) handleFileButtonPress(i);
    }
  }
}

// Function to draw gauge on sprite
void drawGaugeToSprite(TFT_eSprite* sprite, int x, int y, float min_val, float max_val, float value, const char* label, uint16_t color, uint16_t bgColor) {
  sprite->fillSprite(TFT_BLACK);
  
  // Calculate scaling factor for VOC gauge (98px vs 140px)
  float scale = (sprite->width() == 98) ? 0.7 : 1.0;
  int outerRadius = round(62 * scale);
  int innerRadius = round(58 * scale);
  bool isVOC = (sprite->width() == 98);
  int fillRadius = round(54 * scale);
  int centerRadius = round(35 * scale);
  
  // Adjust fill radius for VOC gauge to ensure visibility
  if (sprite->width() == 98) {
    fillRadius = round(58 * scale);  // Increased fill radius for VOC
    innerRadius = round(52 * scale); // Adjusted inner radius
  }

  // Draw outer circle with anti-aliasing
  sprite->drawCircle(x, y, outerRadius, TFT_WHITE);
  for(int i = round(59 * scale); i >= round(58 * scale); i--) {
    sprite->drawCircle(x, y, i, TFT_DARKGREY);
  }

  // Draw tick marks only for non-VOC gauges
  if (!isVOC) {
    int radius = round(58 * scale);
    for (int i = -225; i <= 45; i += 27) {
      float rad = i * PI / 180.0;
      int len = (i == -225 || i == 45 || i == -90) ? round(12 * scale) : round(8 * scale);
      // Draw anti-aliased tick marks
      for(int w = 0; w < 1; w++) {
        sprite->drawLine(
          x + cos(rad) * (radius-w), 
          y + sin(rad) * (radius-w),
          x + cos(rad) * (radius-len-w), 
          y + sin(rad) * (radius-len-w),
          (i == -225 || i == 45 || i == -90) ? TFT_WHITE : TFT_DARKGREY
        );
      }
    }
  }

  // Calculate angles with improved precision
  float startAngle = -225 * PI / 180.0;
  float mappedValue = constrain(value, min_val, max_val);
  float endAngle = -225 + (mappedValue - min_val) * (270) / (max_val - min_val);
  endAngle = endAngle * PI / 180.0;
  
  // Adjust fill radius for VOC gauge
  int fillStart = isVOC ? round(58 * scale) : round(54 * scale);
  int fillEnd = round(42 * scale);
  
  // Draw filled arc with smoother gradient and anti-aliasing
  for (int r = fillStart; r >= fillEnd; r--) {
    float stepSize = 0.01; // Smaller step size for smoother arc
    for (float angle = startAngle; angle <= endAngle; angle += stepSize) {
      float nextAngle = min(angle + stepSize, endAngle);
      // Draw multiple lines for anti-aliasing
      for(int w = 0; w < 2; w++) {
        sprite->drawLine(
          x + cos(angle) * (r-w), 
          y + sin(angle) * (r-w),
          x + cos(nextAngle) * (r-w), 
          y + sin(nextAngle) * (r-w),
          color
        );
      }
    }
  }

  // Draw inner circle with scaled dimensions
  for(int r = round(41 * scale); r >= round(36 * scale); r--) {
    uint8_t shadow = map(r, round(38 * scale), round(36 * scale), 46, 0);
    sprite->drawCircle(x, y, r, sprite->color565(shadow, shadow, shadow));
  }
  sprite->fillCircle(x, y, centerRadius, bgColor);

  // Draw labels and value
  char buf[10];
  if (strstr(label, "VOC")) {
    sprintf(buf, "%d", (int)value); // Integer format for VOC
  } else {
    sprintf(buf, "%.1f", value); // Keep decimal for temp and humidity
  }
  
  sprite->setTextColor(TFT_WHITE, bgColor);
  // Adjust text size and position for VOC gauge
  int textSize = (sprite->width() == 98) ? 2 : 4;
  sprite->drawCentreString(buf, x, y-(round(16 * scale)), textSize);
  
  sprite->setTextSize(1);
  sprite->setTextColor(TFT_WHITE, bgColor);
  sprite->drawCentreString(label, x, y+5, 2);
}

void displayLoadingScreen() {
  tft.fillScreen(TFT_BLACK);
  tft.setTextColor(TFT_WHITE);
  tft.setFreeFont(LABEL2_FONT);
  tft.setTextSize(1);
  
  const char* loadingText = "Loading Files";
  tft.drawString(loadingText, 60, 140);

  // Faster animation with shorter delays
  for(int i = 0; i < 3; i++) {
    tft.drawString(".", 180 + (i * 10), 140);
    delay(150);
    yield(); // Prevent watchdog issues
  }
  delay(200); // Short pause before next screen
}

void displayScreen(int screen) {  // Update screen display logic
  // Clean up sprites before switching screens, but preserve main menu sprite
  if (screen != 0) {
    cleanupSprites();
  }
  
  // Always ensure menuSprite exists
  if (!menuSprite.created()) {
    menuSprite.createSprite(240, 320);
    Serial.println("Created menuSprite");
  }
  
  tft.fillScreen(TFT_BLACK);  // Clear the screen
  
  if (screen != 0) {  // Only show back button when not on main menu
    tft.setFreeFont(LABEL2_FONT);
    screenButton.initButton(&tft, 200, 20, 60, 30, TFT_WHITE, TFT_BLUE, TFT_WHITE, backButtonLabel, 1);
    screenButton.drawButton();
  }

  if (neopixelState) {  // Only update NeoPixel if it's enabled
    setNeoPixelColor(screen);  // Update NeoPixel color
  }

  switch (screen) {
    case 0:
      drawMainMenu(); // Display Main Menu
      break;
    case 1:
      displayPID();  // PID
      break;
    case 2:
      displayBGBrightness(); // Display Backlight Control screen
      break;
    case 3:
      displayTempAndAirQuality();
      break;
    case 4:
      displayFileExplorer();  // Display file explorer
      break;
    case 5:
      displaySettings();  // Display settings
      break;
    case 6:
      displayLEDControl();  // Display LED Control screen
      break;
    case 7:
      displayFanControl(0);  // Display Fan Control screen
      break;
    case 8:
      displayInfoScreen();  // Display system information screen
      break;
  }
}
void drawMainMenu() {
  // Create menuSprite if it doesn't exist
  if (!menuSprite.created()) {
    menuSprite.createSprite(240, 320);
  }
  
  // Draw to sprite instead of directly to screen
  menuSprite.fillSprite(TFT_DARKCYAN);
  menuSprite.setTextColor(TFT_WHITE);
  menuSprite.setFreeFont(&Yellowtail_32);
  menuSprite.setTextSize(1);
  menuSprite.setCursor(50, 50);
  menuSprite.print("Main Menu");
  menuSprite.setFreeFont(LABEL2_FONT);

  // Initialize buttons with menuSprite instead of tft
  mainMenuButtons[0].initButton(&menuSprite, 120, 100, 220, 40, TFT_WHITE, TFT_BLUE, TFT_WHITE, (char*)"Fans", 1); // Replaced Screen 1 with Fans
  mainMenuButtons[1].initButton(&menuSprite, 120, 160, 220, 40, TFT_WHITE, TFT_BLUE, TFT_WHITE, (char*)"Temp", 1);
  mainMenuButtons[2].initButton(&menuSprite, 120, 220, 220, 40, TFT_WHITE, TFT_BLUE, TFT_WHITE, (char*)"PID", 1);
  mainMenuButtons[3].initButton(&menuSprite, 120, 280, 220, 40, TFT_WHITE, TFT_DARKGREY, TFT_WHITE, (char*)"Settings", 1);

  for (uint8_t i = 0; i < 4; i++) {  // Adjusted loop to 3 buttons
    mainMenuButtons[i].drawButton();
  }
  
  // Push sprite to display
  menuSprite.pushSprite(0, 0);
}

//////
void displayPID() {

 // Berechne PID-Output nur, wenn PID aktiv ist
  if (PIDactive==true) {
  float gap = abs(Setpoint - temp); //distance away from setpoint
  if (gap < 2) { //we're close to setpoint, use conservative tuning parameters
    myPID.SetTunings(consKp, consKi, consKd);
  } else {
    //we're far from setpoint, use aggressive tuning parameters
    myPID.SetTunings(aggKp, aggKi, aggKd);
    myPID.Compute();
   }
   Fan_PWM[0]->setPWM(FAN1_PIN, fanFrequency, fanSpeed2);
   Fan_PWM[1]->setPWM(FAN2_PIN, fanFrequency, fanSpeed2);
   Fan_PWM[2]->setPWM(FAN3_PIN, fanFrequency, fanSpeed2);
  }
  // Create title bar with gradient
  for(int i = 0; i < 40; i++) {
    uint16_t gradientColor = tft.color565(0, i * 2, i * 4);
    tft.drawFastHLine(0, i, 240, gradientColor);
  }
  
  // Title with shadow effect
  tft.setTextColor(TFT_DARKGREY);
  tft.setFreeFont(&FreeSansBold12pt7b);
  tft.setCursor(11, 31);
  tft.print("PID Control");
  tft.setTextColor(TFT_WHITE);
  tft.setCursor(10, 30);
  tft.print("PID Control");

   // Draw circular temperature gauge
  int centerX = 120;
  int centerY = 120;
  int radius = 60;
  
  // Draw outer ring with gradient
  for(int r = radius; r > radius-5; r--) {
    float tempRatio = (temp - 20) / 40.0; // Assuming range 20-60°C
    uint16_t gaugeColor = tft.color565(255 * tempRatio, 255 * (1-tempRatio), 0);
    tft.drawCircle(centerX, centerY, r, gaugeColor);
  }
  
  // Draw inner ring for target temperature
  for(int r = radius-8; r > radius-12; r--) {
    float targetRatio = (Setpoint - 20) / 40.0;
    uint16_t targetColor = tft.color565(0, 255 * (1-targetRatio), 255 * targetRatio);
    tft.drawCircle(centerX, centerY, r, targetColor);
  }

  // Temperature display in center
  tft.setTextColor(TFT_WHITE);
  tft.setFreeFont(&FreeSansBold9pt7b);
  tft.setCursor(centerX-30, centerY-10);
  tft.printf("%.1f°C", temp);
  tft.setFreeFont(&FreeSans9pt7b);
  tft.setCursor(centerX-25, centerY+20);
  tft.printf("/ %.1f°C", Setpoint);

  // Modern toggle switch for PID
  int toggleX = 30;
  int toggleY = 280;
  tft.fillRoundRect(toggleX, toggleY, 60, 30, 15, PIDactive ? TFT_GREEN : TFT_DARKGREY);
  tft.fillCircle(toggleX + (PIDactive ? 45 : 15), toggleY + 15, 12, TFT_WHITE);
  
  // Stylish up/down buttons
  drawRoundButton(190, 200, 40, 40, "+", TFT_BLUE);
  drawRoundButton(190, 260, 40, 40, "-", TFT_BLUE);
  
  // PID terms visualization
  int barX = 20;
  int barY = 195;
  drawPIDBar(barX, barY, "P", myPID.GetPterm(), TFT_RED);
  drawPIDBar(barX, barY + 25, "I", myPID.GetIterm(), TFT_GREEN);
  drawPIDBar(barX, barY + 50, "D", myPID.GetDterm(), TFT_BLUE);

  // Draw back button
  screenButton.initButton(&tft, 200, 20, 60, 30, TFT_WHITE, TFT_BLUE, TFT_WHITE, backButtonLabel, 1);
  screenButton.drawButton();

  // Anzeige aktualisieren
  updatePIDDisplay();
}

// Helper function to draw rounded buttons
void drawRoundButton(int x, int y, int w, int h, const char* label, uint16_t color) {
  tft.fillRoundRect(x, y, w, h, 10, color);
  tft.drawRoundRect(x, y, w, h, 10, TFT_WHITE);
  tft.setTextColor(TFT_WHITE);
  tft.setFreeFont(&FreeSansBold9pt7b);
  tft.setCursor(x + w/2 - 5, y + h/2 + 5);
  tft.print(label);
}

// Helper function to draw PID term bars
void drawPIDBar(int x, int y, const char* term, float value, uint16_t color) {
  tft.setTextColor(TFT_WHITE);
  tft.setFreeFont(&FreeSans9pt7b);
  tft.setCursor(x, y+15);
  tft.print(term);
  int barWidth = constrain(abs(value) * 20, 0, 100);
  tft.fillRect(x+20, y, barWidth, 20, color);
  tft.drawRect(x+20, y, 100, 20, TFT_DARKGREY);
}

void updatePIDDisplay() {
  unsigned long currentMillis = millis();
  lastSensorUpdate = currentMillis;

  int centerX = 120;
  int centerY = 120;
  int radius = 60;
  
  // Draw outer ring with gradient
  for(int r = radius; r > radius-5; r--) {
    float tempRatio = (temp - 20) / 40.0; // Assuming range 20-60°C
    uint16_t gaugeColor = tft.color565(255 * tempRatio, 255 * (1-tempRatio), 0);
    tft.drawCircle(centerX, centerY, r, gaugeColor);
  }
  
  // Draw inner ring for target temperature
  for(int r = radius-8; r > radius-12; r--) {
    float targetRatio = (Setpoint - 20) / 40.0;
    uint16_t targetColor = tft.color565(0, 255 * (1-targetRatio), 255 * targetRatio);
    tft.drawCircle(centerX, centerY, r, targetColor);
  }

  // Temperature display in center
  tft.setTextColor(TFT_WHITE);
  tft.setFreeFont(&FreeSansBold9pt7b);
  tft.setCursor(centerX-30, centerY-10);
  tft.printf("%.1f°C", temp);
  tft.setFreeFont(&FreeSans9pt7b);
  tft.setCursor(centerX-25, centerY+20);
  tft.printf("/ %.1f°C", Setpoint);

  // Modern toggle switch for PID
  int toggleX = 30;
  int toggleY = 280;
  tft.fillRoundRect(toggleX, toggleY, 60, 30, 15, PIDactive ? TFT_GREEN : TFT_DARKGREY);
  tft.fillCircle(toggleX + (PIDactive ? 45 : 15), toggleY + 15, 12, TFT_WHITE);
  
 
  // PID terms visualization
  int barX = 20;
  int barY = 195;
  drawPIDBar(barX, barY, "P", myPID.GetPterm(), TFT_RED);
  drawPIDBar(barX, barY + 25, "I", myPID.GetIterm(), TFT_GREEN);
  drawPIDBar(barX, barY + 50, "D", myPID.GetDterm(), TFT_BLUE);


  if (PIDactive==true) {
  float gap = abs(Setpoint - temp); //distance away from setpoint
  if (gap < 2) { //we're close to setpoint, use conservative tuning parameters
    myPID.SetTunings(consKp, consKi, consKd);
  } else {
    //we're far from setpoint, use aggressive tuning parameters
    myPID.SetTunings(aggKp, aggKi, aggKd);
    myPID.Compute();
   }
  }

   Serial.println();
  Serial.print(F(" Setpoint: "));  Serial.println(Setpoint);
  Serial.print(F(" Input:    "));  Serial.println(temp);
  Serial.print(F(" Output:   "));  Serial.println(fanSpeed2);
  Serial.print(F(" Pterm:    "));  Serial.println(myPID.GetPterm());
  Serial.print(F(" Iterm:    "));  Serial.println(myPID.GetIterm());
  Serial.print(F(" Dterm:    "));  Serial.println(myPID.GetDterm());
  Serial.print(F(" Control:  "));  Serial.println(myPID.GetMode());
  Serial.print(F(" Action:   "));  Serial.println(myPID.GetDirection());
  Serial.print(F(" Pmode:    "));  Serial.println(myPID.GetPmode());
  Serial.print(F(" Dmode:    "));  Serial.println(myPID.GetDmode());
  Serial.print(F(" AwMode:   "));  Serial.println(myPID.GetAwMode());
}
